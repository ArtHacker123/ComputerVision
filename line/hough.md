# Hough Transform/霍夫变换

霍夫变换是直线检测中的明星算法，我认为有两个原因，第一是它的想法十分独到，一个空间的转换就使得问题得到了很好地解决，第二就是大名鼎鼎的opencv实现了它，速度效果都还算不错。

### 直线检测

为什么要做直线检测？在有些场景下，我们需要找到一张图像上的直线，比方说对于一张名片的照片，我们假设整张名片都被拍摄到了照片里面，那么一个问题就是：名片的范围在哪里？

我们再加一个假设，那就是我们拍摄的照片是大众普遍了解的长方形名片，奇葩形状暂不考虑。对于人眼来说，识别轮廓十分简单，对于计算机来说，识别这个边界就需要一些方法，而其中的一种解决方法就是用霍夫变换。

下面我们把问题做一个定义：

*直线检测：在一个二值图中，每一个像素点的亮度值只可能等于1（前景）或者0（背景），找出由1组成的最长的N条直线*

### 常规解法

上面这个问题其实在一些公司的面试中已经出现过，我相信一些人会想到利用极坐标的方式解决问题：
```python
def lineCheck(mat):
  dots = findAllForegroundDotInMat(mat) # 找到所有前景点
  lineMap = map() # key为直线方程，val为贯穿的点数
  for i in range(len(dots)):
    for j in range(i + 1, len(dots)):
      k, b = fitLine(dots[i], dots[j]) # 利用dots[i], dots[j]两点求一条直线
      if map.exist((k,b)):
        continue
      count = 0
      for k in range(len(dots)):
        if k != i and k != j:
          isInLine = isThroughLine(k, b) # 判断点是否穿过前面求出的直线
          if isInLine:
            count += 1
      if count > 0:
        map.insert((k,b),count)
  # 当求出所有的线和贯穿的点数后，剩下的任务就是找出最大的N个返回，这里不再赘述。
```

上面的代码只为表达思路，如有错误请指出并谅解。

可以看出，上面的问题复杂度为O（n^3)，复杂度还蛮高的。在视觉问题中图像的点数一般在万这个数量级，也就是说这个方法需要进行万亿次的计算，速度之慢可想而知。

### 坐标系变换

接下来首先揭秘霍夫变换的核心思想，那就是空间映射。

简单地说，目前我们常用的笛卡尔坐标系上，点是坐标系上的一个点，线是一组点的集合，那么我们需要换过来————线是坐标系上的一个点，点是一组线的集合。

这样带来什么样的好处？

原来的问题是，坐标系中有N个点，我们找贯穿点最多的M条线

现在的问题是，坐标系中有N条线，我们找交点最多的M个点

问题被转变之后，我们可以用近似的方法解决这个问题，这个方法就是离散化（这个问题后面再说）

下面我们来解决坐标系变换的问题。

我们已知y=kx+b是一般学过的直线表达方程式，其中k=tan(theta)=sin(theta)/cos(theta)表示斜率，我们将公式展开，可以得到：

sin(theta) * x - cos(theta) * y=cos(theta) * (-b)

对于CV的图像，我们一般设为左上角为原点，所以图像实际上是处在第四象限，那么真实的y应该是上式的相反数，我们再将等式右边的常量做一个替换，可以得到：

sin(theta) * x + cos(theta) * y = r

得到了上面这个式子，我们发现，如果给定某个点(x,y)并将其代入上式，那么上式就变成了关于theta和r的函数式，而这个函数式所表达的，正是所有穿过点（x,y）的直线！

于是乎，我们完成了坐标系的转换。

### 离散化

通过上式的转换，我们完成了一种坐标系的转换，就是从`(k,b)`系统转换到`(theta,r)`系统，有人一定会问，这有什么好处，我用`(k,b)`一样可以达到表达穿过某一点的直线的概念啊？

那么，下一步的离散化将展现二者的不同。

我们来看看两个系统的定义域范围：

k:(-infinity, +infinity), b:(-infinity,+infinity)

theta(-PI,+PI), r:(-infinity,+infinity)

这下大家一定明白了，theta的定义域是有界的！那么我们可以对其进行离散化，那么在给定的精度下，我们就能得到有限集的直线信息。

所谓的离散化，就是把一个范围分成等量的N等份，对于每一份，取一个值去代替这个连续区间内的值。举个栗子：

[1, 10]这个区间，我们可以离散化为：[1,2,3,4,5,6,7,8,9,10]，其中步长为1，我们也可以离散化为更小的步长，那么它的数量会增加，精度也会增加。

所以，如果我们对theta进行离散化，就能得到有限个代表所有直线的集合，而原方程的k,b没法做到。

那么大功告成，接下来说一下实现。

### 实现

实现部分直接写代码，根据opencv进行了一定的改编，原[代码见|https://github.com/Itseez/opencv/blob/9c3f95782d095931c13c5dc48455ea2780524691/modules/imgproc/src/hough.cpp]：

```c++
vector<int> _accum((numangle+2) * (numrho+2));
std::vector<int> _sort_buf;
vector<float> _tabSin(numangle);
vector<float> _tabCos(numangle);
```

这里定义了四个核心的数据结构，_accum用来计算某条直线贯穿点的个数，_sort_buf用作后面的排序，_tabSin和_tabCos用于重用三角函数的计算，因为每一个点都要作离散化，所以这样只需调用一次就好。

```c++
// stage 1. fill accumulator
for( i = 0; i < height; i++ )
    for( j = 0; j < width; j++ )
    {
        if( image[i * step + j] != 0 )
            for(int n = 0; n < numangle; n++ )
            {
                int r = cvRound( j * tabCos[n] + i * tabSin[n] );
                r += (numrho - 1) / 2; // 考虑截距为负，需要将其转为正
                accum[(n+1) * (numrho+2) + r+1]++;
            }
    }
```

算法的第一部分，也是我们前面讲到的核心。如果找到一个点，那么根据不同的angle计算不同的r，然后将accum中的（angle,r）对加1

其实做完了这一步，后面就十分简单了，从accum数组中找到值最大的N的数，用上面的公式反解出来就好，关于如何反解的问题其他博客已经讲了很多了。

### 总结

霍夫变换的本质就是转换的问题的空间，利用角度值定义域的有限性对其金星离散化，从而得出了结果。从上面贴出的代码来看，复杂度已经变为o(n^2 * k)，其中k为角度离散化的数量，相信这个数量远小于1万（对于特定任务，角度的范围可以缩减得更小），因此，这比上面的暴力解法会有百倍的速度提升（亲测对于100k像素的图像，对于当代CPU，霍夫变换的峰值大概在100ms）
